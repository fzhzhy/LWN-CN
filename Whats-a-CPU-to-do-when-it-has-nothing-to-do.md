# 当CPU无事可做的时候在做什么

  通常认为无事可做对于内核来说，应该是简单的容易的事情，但事实并非如此。在 Kernel Recipes 2018大会上，Rafael Wysocki 讨论CPU在无事可做的时候都做了些什么，内核如何处理，当前有哪些问题。并且介绍他最近对于idle loop的工作改进了系统在无事可做的时候的能耗。
  Wysocki维护的内核子系统idle loop控制着CPU没有进程运行时的行为。为了便于讨论，Wysocki作如下定义CPU作为一个实体可以从内存中获取并执行指令，同时系统中的其他CPU也同时在做类似事物。在一个简单的单核单处理系统中，核心是CPU。如果处理器有多个核心，每个核心是一个CPU。如果每个核心都是支持多个指令同时执行，Intel叫做超线程，那么每个线程是一个CPU。

如果一个CPU没有task要运行，那么它就在idle。更精确的讲，linux内核拥有若干个内部调度类，其中包含了idle类。如果在给定的CPU上没有task需要运行在某个调度类上，CPU就被认为idle。如果硬件不允许idle，那么CPU需要执行一些无用指令直到他需要真正的工作。然而，这不是高效节能的，所以大多数CPU都支持多级别的低功耗状态，内核可以在真正工作之前，进入某一种低功耗模式。

进出idle状态并不是没有代价的。进入和退出都需要话费一些时间，而且功耗也会在状态切换的时候略微增加。尽管随着idle级别深入，功耗逐级降低，但是在进出低功耗模式的代价却是增加的。（译者注：进出深度休眠状态的功耗，比浅休眠状态的代价高）这意味着，对于短暂空闲周期，相对浅的低功耗模式会较好利用系统资源；对于长期空闲周期，更深度的休眠则会节省更多的功耗。因此内核的一个重要的功能就是预测CPU将会休眠多久，以期决定使用那种低功耗模式。这也就是idle loop的功能。

在此循环中，CPU调度器会通知CPU没有工作要做进入idle，然后调度器通知调节器来尽可能预测合适的休眠状态。目前内核有两类调节器，叫做menu和ladder. 他们用作不同场景，但他们都在做类似的事情：跟踪系统状态，什么时候CPU进入休眠和多久系统停止休眠。这样做就是为了来预测刚刚进入idle的CPU要休眠多久和什么样级别的休眠等级是合适的。

这个工作通过调度器的时钟tick来完成特别困难。这个时钟定时器是调度器用于CPU共享时间片的目的的：如果在一个单核CPU上运行多个任务，每个任务仅仅能运行一段时间，然后时不时的让出来给其他任务。此外如果tick允许运行在另外一个空闲的CPU上，它将减少CPU休眠的时间，来阻止CPU进入深度休眠。在4.16和早期的内核中，调度器在调用调节器之前会禁用tick。当CPU被中断唤醒，调度器来决定是否有work需要执行。如果有，那么激活tick。

如果调节器预期一个长时间的idle，并且idle周期结果也是长的，那么调节器“赢”： CPU将会进入一个深度休眠状态，并且节省功耗。但是如果调节器预期长时间idle，但是结果却是短休眠，那么调节器输了，因为进入深度休眠的代价要超过休眠本身的功耗。更严重的是，如果调节器预期是短期idle，不管真实的休眠周期是长是短，他都输了。如果真实的休眠周期长，潜在的节省的功耗被错过；如果休眠周期短，那么停止和重启tick的代价也是没有必要的。换句话说，由于停止和重启tick是有代价的，如果调节器预期短idle周期，那么停止tick就没有意义。

Wysocki考虑重新设计调节器来修掉这个问题，并且修掉了在调节器调用前，tick就停止的问题。因此Wysocki在内核4.17上重构了idle loop，这样调节器决定idle state以后，tick才会停止。如果推荐值是长期的idle，tick被停止并不会过早的唤醒CPU；如果推荐值是短idle，那么tick就保留不会有停止的代价。这意味着，即便idle时间比预期要长，tick也是一个安全的策略。这也给调节器另外一个机会来修正。

当休眠的CPU被中断唤醒，无论中断来自未运行的tick还是其他事件，调度器都会立刻做决定是否有work要做。如果有，tick就被重启（如果有必要）；如果没有work，调节器立刻被再次调用。这意味着无论tick是否运行或者停止，调节器都可以被调用。因此，调度器也需要据此来重构。

根据以上评估损益表，Wysocki 预期会带来改进。如果预测长时间的idle，tick仍旧被停止；如果实际idle是长周期的，那么调节器“赢”，如果实际idle是短，那么调节器“输”。但是，如果预测短时间的idle， 结果就会更好：如果实际是短idle，重启和停止tick的代价就被节省；如果实际是长idle，未停止的timer就会唤醒并给我另外一个预测的机会。

![Comparison Graph](https://static.lwn.net/images/2018/kr-rw-graph.jpg)

鉴于理论不代表真实世界，Sysocki在一系列系统做了实验。上述图表表征了系统在idle时期的功耗特性。绿色线条是旧idle loop，红色是新代码： 新方案的功耗更好，预测更准确。可以看出并不是所有的系统都有显著gap，但是红色平坦的线条明显优于绿色折线。如Wysocki说说，新方案预测短idle要比老方案少，但这样做是正确的。

作为对听众问题的回答，Sysocki这个工作是和架构无关的。Intel CPU获益更多，因为Intel CPU有相对数量更多的休眠状态，新方案让调节器更容易做出最优选择，对于ARM CPU也是有益的。

![CPU use](https://static.lwn.net/images/2018/kr-ty-graph.png)

看起来20%的空负载功耗下降微小，但事实并非如此。任何想要合理利用峰值负载的系统，在正常运行的时候都要考虑空闲的能力，这表现为空闲时间。上述图表显示了 邮件/talk/文件传输/VPN/NTP等应用的CPU使用情况。对于服务器来说，在过去一年里，（亮黄色部分是空闲时间）节省20%的能耗会让我的供应商满意，而且对我们的地球也有好处。